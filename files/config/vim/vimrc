" Early stuff {{{
" Leaders {{{
" These have to be put here in order to work, otherwise the plugin keybindings
" don't pick up the leader change
let mapleader = ","
let maplocalleader = "´"

" }}}
" A word on runtimepath settings. {{{
" Vundle adds the rtps of its bundles to the beginning of an existing
" runtimepath, and its bundle/after rtps at the end of the existing
" runtimepath. Since Vim gives higher priority to files that are earlier in
" the runtimepath, this leads to bundle settings having higher precedence than
" user settings, which just shouldn't happen. In order to alleviate that
" problem, I wait after Vundle has initialized all its bundles before I set
" the remaining part of the runtimepath. It should look like this:
"
"   u - b - s -- sa - ba - ua
"
"   u = User settings (highest priority)
"   b = Bundle settings (second highest)
"   s = System settings (lowest priority)
"   sa = system after/ directories
"   ba = Bundle after/ directories
"   ua = User after/ directories
"
"   This way, user settings take precedence before bundle and system settings,
"   both in the regular plugin/ftplugin directories as well as in the after/
"   directories. I believe this is the way it should be. }}}
" Early runtimepath dickery!
set runtimepath=$XDG_DATA_HOME/vim/bundle/vundle,$VIM/vimfiles,$VIMRUNTIME,$VIM/vimfiles/after
" Plugins {{{
" Vundle initialization {{{
" Vundle wants this to be off
filetype off
call vundle#rc("$XDG_DATA_HOME/vim/bundle")
" Bundles
Bundle 'gmarik/vundle'
Bundle 'ervandew/ag'
Bundle 'tpope/vim-commentary'
Bundle 'kien/ctrlp.vim'
Bundle 'vim-scripts/DeleteTrailingWhitespace'
Bundle 'tpope/vim-fugitive'
Bundle 'sjl/gundo.vim.git'
Bundle 'ivanov/vim-ipython'
Bundle 'davidhalter/jedi-vim'
Bundle 'LaTeX-Box-Team/LaTeX-Box'
Bundle 'ludovicchabant/vim-lawrencium'
Bundle 'MarcWeber/vim-addon-local-vimrc'
Bundle 'edsono/vim-matchit'
Bundle 'tpope/vim-obsession'
Bundle 'Lokaltog/vim-powerline'
Bundle 'kien/rainbow_parentheses.vim'
Bundle 'tpope/vim-repeat'
Bundle 'vim-scripts/ShowTrailingWhitespace'
Bundle 'tmhedberg/SimpylFold'
Bundle 'sjl/splice.vim.git'
Bundle 'tpope/vim-surround'
Bundle 'scrooloose/syntastic'
Bundle 'godlygeek/tabular'
Bundle 'majutsushi/tagbar'
Bundle 'LStinson/TagmaTasks'
Bundle 'maxbrunsfeld/vim-yankstack'
Bundle 'SirVer/ultisnips'
Bundle 'tpope/vim-unimpaired'
Bundle 'ervandew/supertab'
filetype plugin indent on
" }}}
" Configuration {{{
" Some preliminary remarks:
" - all plugin functions that open some kind of split window have mapped that
"   the opening/toggling of said window to a function key
" - functions that toggle other stuff are normally either <leader><key> if I
"   use them sparingly, or use their own keys if I use them often (e.g.
"   commentary and üü)
" Ag {{{
noremap <leader>a :Ag<space>

" }}}
" CtrlP {{{
" Keybinding for CtrlP in normal mode
let g:ctrlp_map = '<leader>e'
" Cache directory
let g:ctrlp_cache_dir = expand("$XDG_CACHE_HOME/vim/ctrlp")
" Use extensions:
" - mixed
let g:ctrlp_extensions = ['mixed']
" Normal Ctrlp
noremap <silent> <leader>e :CtrlP<cr>
" CtrlP in find buffer mode
noremap <silent> <leader>b :CtrlPBuffer<cr>
" CtrlP with root dir search disabled
noremap <silent> <leader>E :CtrlPRoot<cr>
" CtrlP in mixed mode
noremap <silent> <leader>x :CtrlPMixed<cr>

" }}}
" DeleteTrailingWhitespace {{{
" Don't automatically delete on writing a buffer
let g:DeleteTrailingWhitespace = 0
" Do this to fix trailing whitespace
noremap <silent> <leader>d<space> :DeleteTrailingWhitespace<cr>

" }}}
" Fugitive {{{
" Mappings are done in a function because they are used as autocommands
function! s:setup_fugitive_mappings()
    " Edit fugitive-revision (with repo basedir as working directory)
    noremap <buffer> <leader>ve<space> :Gedit<space>
    " Edit fugitive-revision in split
    noremap <buffer> <leader>ves :Gsplit<space>
    " Edit fugitive-revision in vertical split
    noremap <buffer> <leader>vev :Gvsplit<space>
    " Edit fugitive-revision in new tab
    noremap <buffer> <leader>vet :Gtabedit<space>
    " Edit fugitive-revision in preview window
    noremap <buffer> <leader>vet :Gpedit<space>
    " Read output of git command in current buffer
    noremap <buffer> <leader>vE :Gread!<space>
    " Read output of git command in new split
    noremap <buffer> <leader>veS :Gsplit!<space>
    " Read output of git command in vertical split
    noremap <buffer> <leader>veV :Gvsplit!<space>
    " Read output of git command in new tab
    noremap <buffer> <leader>veT :Gtabedit!<space>
    " Read output of git command in preview window
    noremap <buffer> <leader>veP :Gpedit!<space>
    " :cd relative to repository
    noremap <buffer> <leader>vcd :Gcd<space>
    " :lcd relative to repository
    noremap <buffer> <leader>vcl :Glcd<space>
    " Move file and rename buffer accordingly
    noremap <buffer> <leader>vm :Gmove<space>
    " Move file and rename buffer accordingly (overwrite if necessary)
    noremap <buffer> <leader>vM :Gmove!<space>
    " Do :w and stage results
    noremap <silent> <buffer> <leader>vw :Gwrite<cr>
    " Do :w, stage results, do :q
    noremap <silent> <buffer> <leader>vwq :Gwq<cr>
    " Do :w and stage results
    noremap <silent> <buffer> <leader>vW :Gwrite!<cr>
    " Do :w, stage results, do :q
    noremap <silent> <buffer> <leader>vwQ :Gwq!<cr>
    " Remove current file and delete buffer
    noremap <buffer> <leader>vrm :Gremove<cr>
    " Remove current file and delete buffer forcefully
    noremap <buffer> <leader>vrM :Gremove!<cr>
    " Open annotation window ("git blame", but who's counting)
    noremap <silent> <buffer> <leader>va :Gblame<cr>
    " Browse on GitHub, if possible
    noremap <silent> <buffer> <leader>vb :Gbrowse<cr>
    " Put GitHub URL in clipboard
    noremap <silent> <buffer> <leader>vB :Gbrowse!<cr>
    " Open status window
    noremap <silent> <buffer> <leader>vs :Gstatus<cr>
    " Show list of revisions for current file in location list
    noremap <silent> <buffer> <leader>vl :Gllog<cr>
    " Show list of commits for current file in location list
    noremap <silent> <buffer> <leader>vL :Gllog --<cr>
    " Open diff window
    noremap <silent> <buffer> <leader>vd :Gsdiff<cr>
    " Open vertical diff window
    noremap <silent> <buffer> <leader>vvd :Gvdiff<cr>
    " :Glgrep
    noremap <buffer> <leader>vg :Glgrep<space>
    " :Ggrep
    noremap <buffer> <leader>vG :Ggrep<space>
    " Open commit buffer (or status buffer if there's nothing staged)
    noremap <silent> <buffer> <leader>vC :Gcommit<cr>
endfunction
" }}}
" Gundo {{{
" Toggles the Gundo windows
" It looks kinda like a tree, see? See?
noremap <f3> :GundoToggle<cr>
" horizontal width of Gundo graph
let g:gundo_width = 50
" Vertical height of preview window
"let g:gundo_preview_height = 25
" Show preview window below file instead of below graph
" let g:gundo_preview_bottom = 0
" Show Gundo graph on the right
"let g:gundo_right = 1
" automatically close Gundo windows on reverting
let g:gundo_close_on_revert = 1

" }}}
" Lawrencium {{{
" I like my own mappings better
let g:lawrencium_define_mappings = 0
" As for fugitive: mappings are done in a function because they are used as
" autocommands
function! s:setup_lawrencium_mappings()
    " :Hgedit
    noremap <buffer> <leader>ve :Hgedit<space>
    " :Hgcd
    noremap <buffer> <leader>vcd :Hgcd<space>
    " :Hglcd
    noremap <buffer> <leader>vcl :Hglcd<space>
    " Open annotation window
    noremap <silent> <buffer> <leader>va :Hgannotate<cr>
    " Open status window
    noremap <silent> <buffer> <leader>vs :Hgstatus<cr>
    " Open log window for current file
    noremap <silent> <buffer> <leader>vl :Hglogthis<cr>
    " Open log window for entire repository
    noremap <silent> <buffer> <leader>vL :Hglog<cr>
    " Open diff window
    noremap <silent> <buffer> <leader>vd :Hgdiff<cr>
    " Open vertical diff window
    noremap <silent> <buffer> <leader>vvd :Hgvdiff<cr>
    " Open diffsum window
    noremap <silent> <buffer> <leader>vD :Hgdiffsumsplit<cr>
    " Open vertical diffsum window
    noremap <silent> <buffer> <leader>vvD :Hgvdiffsumsplit<cr>
    " Open commit buffer
    noremap <silent> <buffer> <leader>vC :Hgcommit<cr>
    " Open vertical commit buffer
    noremap <silent> <buffer> <leader>vvC :Hgvcommit<cr>
    " Revert current file to previous revision
    noremap <silent> <buffer> <leader>vr :Hgrevert<cr>
    " Revert current file to previous revision (no backup)
    noremap <silent> <buffer> <leader>vR :Hgrevert!<cr>
endfunction
" }}}
" Obsession {{{
" Sets up keybinding, invoked in autocmd below
" Place for session file depends on whether current file is in Git/Hg repo or
" not: For repos, session file is $reporoot/.session.vim, for non-repo files,
" the session file is saved at ./.session.vim
function! s:obsession() " {{{{
    if exists('b:mercurial_dir')
        let dir = fnamemodify(b:mercurial_dir, ':p:h')
    elseif exists('b:git_dir')
        " b:git_dir points to the actual .git directory
        let dir = fnamemodify(b:git_dir, ':p:h:h')
    else
        let dir = fnamemodify(getcwd(), ':p:h')
    endif
    let fname = fnameescape(dir . "/.session.vim")
    execute 'Obsession ' . fname
endfunction " }}}
noremap <silent> <leader>o :call <SID>obsession()<cr>
noremap <silent> <leader>O :Obsession!<cr>
" }}}
" Powerline {{{
" Set mode names
let g:Powerline_mode_n = ' N '
let g:Powerline_mode_i = ' I '
let g:Powerline_mode_R = ' R '
let g:Powerline_mode_v = ' V '
let g:Powerline_mode_V = 'VLN'
let g:Powerline_mode_cv = 'VBL'
let g:Powerline_mode_s = ' S '
let g:Powerline_mode_S = 'SLN'
let g:Powerline_mode_cs = 'SBL'
" TODO: Theme
" }}}
" Rainbow Parentheses {{{
" TODO:
" - Add explicit color mappings
" Toggle display of all kinds of parens
noremap <silent> <leader>r :RainbowParenthesesToggleAll<cr>

" }}}
" ShowTrailingWhitespace {{{
" Show it by default
let g:ShowTrailingWhitespace = 1
" ZOMGWTFBBQ
" I mean, toggle trailing whitespace display for current buffer
noremap <silent> <leader><space> :<c-u>call ShowTrailingWhitespace#Toggle(0)<bar>echo (ShowTrailingWhitespace#IsSet() ? 'Showing trailing whitespace' : 'Not showing trailing whitespace')<cr>
"
" }}}
" Splice {{{
" Use this as the splice prefix
let g:splice_prefix = "<leader>s"
" Use scrollbind on all modes
let g:splice_initial_scrollbind_grid = 1
let g:splice_initial_scrollbind_loupe = 1
let g:splice_initial_scrollbind_compare = 1
let g:splice_initial_scrollbind_path = 1

" }}}
" Supertab {{{
" Let supertab make out completion context
" Uses completefunc if set, or else omnifunc
" Else: Falls back to secondary default as specified by
" g:SuperTabContextDefaultCompletionType
let g:SuperTabDefaultCompletionType = "context"
" Use this as fallback
let g:SuperTabContextDefaultCompletionType = "<c-n>"
" Complete longest common match (like in shells)
let g:SuperTabLongestEnhanced = 1
" Automatically select first entry in menu
let g:SuperTabLongestHighlight = 1
" Use this to move forward
let g:SuperTabMappingForward = "<tab>"
" Use this to move backward
let g:SuperTabMappingBackward = "<s-tab>"
" Use this to display the normal <tab> character (is still affected by
" expandtab, shiftwidth, etc.)
" Doesn't work in terminal
let g:SuperTabMappingTabLiteral = "<c-tab>"
" Use <cr> to cancel completion
let g:SuperTabCrMapping = 1
" Automatically close preview window when popup window is closed
let g:SuperTabClosePreviewOnPopupClose = 1

" }}}
" Syntastic {{{
" Don't run Syntastic on opening files
let g:syntastic_check_on_open = 0
" Print error message for current line to command window
let g:syntastic_echo_current_error = 1
" Use the :sign interface to show errors
let g:syntastic_enable_signs = 1
" Use these symbols for errors, warnings, and style errors/warnings
let g:syntastic_error_symbol = 'E'
let g:syntastic_warning_symbol = 'W'
let g:syntastic_style_error_symbol = 'S'
let g:syntastic_style_warning_symbol = 's'
" Don't use balloons
let g:syntastic_enable_balloons = 0
" Don't use syntax highlighting
let g:syntastic_enable_highlighting = 0
" Don't automatically jump to the first error when first opening a file
let g:syntastic_auto_jump = 0
" Automatically close location list when no more errors are found
let g:syntastic_auto_loc_list = 2
" Error list height = command window height
let g:syntastic_loc_list_height = 7
" Don't automatically check
let g:syntastic_mode_map = { 'mode': 'passive' }
" Check manually
noremap <leader>S :SyntasticCheck<cr>

" }}}
" Tagbar {{{
" Open tagbar window on the left
let tagbar_left = 1
" Make tagbar window as wide as the gundo plugin windows
let tagbar_width = 50
" Automatically jump to tagbar window as soon as it's opened
let tagbar_autofocus = 1
" Automatically close tagbar window when choosing a tag
let tagbar_autoclose = 1
" If current tag is inside a closed fold, open that fold just enough to show
" the tag
let tagbar_autoshowtag = 1
" Toggle Tagbar window
nnoremap <silent> <f4> :TagbarToggle<cr>

" }}}
" TagmaTasks {{{
" Since tasks are generated in the quickfix/location list windows, their
" bindings can be used
" Don't create marks
let g:TagmaTasksMarks = 0
" I could either use a regex or list of tokens to look for – I'll go with the
" regex
let g:TagmaTasksRegexp = '\<\(FIXME\|TODO\|TASK\)\>\|\\todo{\|\\missingfigure{'
" Again, I like using my own keybindings
let g:TagmaTasksPrefix = ''
" I'll also use the location list keybindings for moving between errors
" instead of those defined in this plugin
let g:TagmaTasksJumpKeys = 0
" Toggle task window
map <silent> <f5> <Plug>TagmaTaskToggle
" }}}
" UltiSnips {{{
" Snippet directory for private snippets
let g:UltiSnipsSnippetsDir = expand("$XDG_DATA_HOME/vim/snippets")
" Snippet search path
" The default snippets are in <bundledir>/ultisnips/UltiSnips directory
let g:UltiSnipsSnippetDirectories = ["snippets", "UltiSnips"]
" " Use this to expand a trigger (i.e. insert a snippet)
let g:UltiSnipsExpandTrigger = "<tab>"
" Use this to jump forward to next trigger
let g:UltiSnipsJumpForwardTrigger = "<tab>"
" Use this to jump backward to next trigger
let g:UltiSnipsJumpBackwardTrigger = "<s-tab>"
" NOTE: UltiSnips automatically falls back on Supertab completion if there's
" no snippet to expand

" }}}
" Yankstack {{{
" Don't load default maps
let g:yankstack_map_keys = 0
"map Use + and - to cycle through yank stack
nmap <silent> + <Plug>yankstack_substitute_older_paste
nmap <silent> - <Plug>yankstack_substitute_newer_paste
" Use this to show yank stack
nnoremap <f2> :Yanks<cr>
" Needs to be called before redefining yank maps
call yankstack#setup()

" }}}

" }}}

" }}}
" Late runtimepath dickery!
set runtimepath^=$XDG_DATA_HOME/vim runtimepath+=$XDG_DATA_HOME/vim/after

" }}}
" General {{{
syntax enable
set background=light
colorscheme summerfruit256
" I want to use LaTeX as my main TeX flavor, thank you very much
" Also, it's kind of a pain in the ass having to set this in .vimrc, though
" that's probably just my ignorance speaking
let g:tex_flavor = "latex"
" (Almost) disable the delay after keycodes
" Attention: Disabling the delay completely by setting noesckeys would disable
" the delay altogether, making the cursor and function keys nonfunctional in
" insert mode
" Attention: I use these dotfiles over SSH and a VPN, so setting this to a
" too-low value might cause problems. If it does, expect this value to change.
set ttimeoutlen=50

" Files {{{
" Don't create backup files
set nobackup
" Save viminfo file to keep state information from one vim session to the next
set viminfo+="n$XDG_CACHE_HOME/vim/viminfo"
" Common directory for all swap files (first existing directory is used)
set directory=$XDG_CACHE_HOME/vim/swap
" Persistent undo (see ":help persistent-undo")
set undofile
" Common directory for persistent undo files
set undodir=$XDG_CACHE_HOME/vim/undo

" }}}
" Indentation & linebreaks {{{
" 1 tab = 8 spaces
" Don’t fuck with this
set tabstop=8
" Number of spaces to use for each step of (auto)indent
set shiftwidth=4
" Tab at start of line inserts shiftwidth, tab anywhere else inserts
" tabstop/softtabstop
set smarttab
" Replace tabs with spaces
" To put actual tab, use <c-v><tab>
set expandtab
" Use this when pressing <tab> instead of tabstop
" Allows to keep tabstop at default value while editing as if it's set to
" softtabstop width
set softtabstop=4

" }}}
" Search {{{
" Show search hits during input
set incsearch
" highlight search hits
set hlsearch
" Case-insensitive search unless there are capital letters in search expression
set ignorecase
set smartcase
" Use ":s///g" by default
set gdefault

" }}}
" Tabs & buffers {{{
" Lets you leave edited buffers without having to save them
set hidden
" When splitting, only split current viewport
set noequalalways
" When splitting, create new viewports below/right to current viewports
set splitbelow
set splitright
" Prettify splits, diffs, folds
set fillchars="vert: ,fold: ,diff: "
" Jump to other windows in current tab if they contain the requested buffer
set switchbuf=useopen

" }}}
" Appearance {{{
" Breaks lines in sane places
set linebreak
" Add this in front of line if line is too long for terminal
set showbreak=+

" At all times show at least this many lines over/under cursor
set scrolloff=3
" Not necessary because of powerline plugin
set noshowmode
" Show current command in status line
set showcmd
" Show tabline only if there is >1 tab
set showtabline=1
" Always show status line
set laststatus=2

" }}}
" Mouse {{{
" Use mouse
set mouse=a

" }}}
" Completion {{{
" Show a popup even if there's only one option
" Show preview window
" Complete to longest common substring
set completeopt=menuone,preview,longest
set wildmenu
set wildmode=longest:full,full

" }}}

" }}}
" Functions {{{
" Customize  fold text: just fold text with length appended {{{
function! CustomFoldText()
    "get first non-blank line
    let fs = v:foldstart
    while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
    endwhile
    if fs > v:foldend
        let line = getline(v:foldstart)
    else
        let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
    endif

    let foldSize = 1 + v:foldend - v:foldstart
    let foldSizeStr = " (" . foldSize . " lines)"
    return line . foldSizeStr
endf
set foldtext=CustomFoldText()

" }}}
" Check if I should set up Lawrencium or Fugitive keybindings {{{
function! s:setup_vcs_keybindings()
    if exists('b:keybindings_setup')
        return
    endif
    let b:keybindings_setup = 1

    if exists('b:mercurial_dir')
        call s:setup_lawrencium_mappings()
    elseif exists('b:git_dir')
        call s:setup_fugitive_mappings()
    endif
endfunction

" }}}

" }}}
" Keybindings {{{
" Fucking keys {{{
" Fuck you, man key
noremap K <nop>

" }}}
" Movement {{{
" Makes opening command line easier
nnoremap ü :
vnoremap ü :

" This is similar to the US-English keyboard layout and makes typing bracket
" commands a LOT easier
nmap ö [
vmap ö [
nmap ä ]
vmap ä ]
" OMG I love bracket commands

" Easier movement between virtual lines
noremap <silent> j gj
noremap <silent> k gk
noremap <silent> gj j
noremap <silent> gk k

" Easier movement between viewports
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <c-l> <c-w>l
nnoremap <c-h> <c-w>h

" Use <tab> to teleport to matching parens
noremap <tab> %

" }}}
" Command-line window {{{
" Use Q for macros
noremap Q q
" q is often used to close transient windows, so being able to use it without
" a delay is nice
" I'll just use <c-f> on the command line to open the :,/, and ? windows
noremap q <nop>

" allow leaving cmdline-window with <esc>
au CmdwinEnter * nnoremap <buffer> <esc> :quit<cr>
" Select current line without having to enter insert mode
au CmdwinEnter * nnoremap <buffer> <cr> i<cr>

" }}}
" Quickfix and location list windows {{{
" Use unimpaired for the regularly used bracket commands
" Jump to current error
noremap <silent> <leader>cc :cc<cr>
" Open quickfix window
noremap <silent> <leader>co :botright :copen<cr>
" Close quickfix window
noremap <silent> <leader>cC :cclose<cr>
" Open window when there are recognized errors, close it if there are none
noremap <silent> <leader>cw :botright :cwindow<cr>
noremap <silent> <f6> :botright :cwindow<cr>
" Re-read error file
noremap <silent> <leader>cf :cgetfile<cr>
" Re-read error file and jump to first error
noremap <silent> <leader>cj :cfile<cr>
" List all errors
noremap <silent> <leader>cl :clist<cr>
" Go to older quickfix error list
noremap <silent> <leader>c- :colder<cr>
" Go to newer quickfix error list
noremap <silent> <leader>c+ :cnewer<cr>

" NOTE: No location list command changes buffers
" Jump to current error
noremap <silent> <leader>ll :ll<cr>
" Open location list window
noremap <silent> <leader>lo :lopen<cr>
" Close location list window
noremap <silent> <leader>lC :lclose<cr>
" Open window when there are recognized errors, close it if there are none
noremap <silent> <leader>lw :lwindow<cr>
noremap <silent> <f7> :lwindow<cr>
" Re-read error file
noremap <silent> <leader>lf :lgetfile<cr>
" Re-read error file and jump to first error
noremap <silent> <leader>lj :lfile<cr>
" List all errors
noremap <silent> <leader>ll :llist<cr>
" Go to older error location list
noremap <silent> <leader>l- :lolder<cr>
" Go to newer error location list
noremap <silent> <leader>l+ :lnewer<cr>

" }}}
" Completion {{{
" Use <C-J> and <C-K> instead of <C-N> and <C-P>
imap <c-j> <c-n>
imap <c-k> <c-p>

" }}}

" Easier :nohl
noremap <silent> <leader><cr> :nohlsearch<cr>
" Makes folding fun
noremap <silent> <space> za
" Use this to toggle paste mode
set pastetoggle=<f1>
" Make Y behave like D and C
noremap <silent> Y y$

" }}}
" Autocommands {{{
" Check for Git/Mercurial and set up keybindings accordingly
augroup vcscheck
    autocmd!
    " Is executed after BufNewPost as well
    autocmd BufEnter * call s:setup_vcs_keybindings()
    autocmd BufUnload * unlet! b:keybindings_setup
augroup END

" }}}
" vim: foldmethod=marker
